<!DOCTYPE html>
<html>

<head>
    <title>WebGL Text Rendering</title>
    <style>
        canvas {
            display: block;
            margin: 0 auto;
        }
    </style>
</head>

<body>
    <canvas id="canvas"></canvas>
    <script>
        // Define vertex shader
        const vertexShaderSource = `
        attribute vec2 a_position;
        uniform vec2 u_resolution;

        void main() {
          vec2 clipSpace = (a_position / u_resolution) * 2.0 - 1.0;
          gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
        }
      `;

        // Define fragment shader
        const fragmentShaderSource = `
        precision mediump float;
        uniform vec4 u_color;

        void main() {
          gl_FragColor = u_color;
        }
      `;

        // Get canvas and WebGL context
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl');

        // Define WebGL program
        const program = createProgram(gl, vertexShaderSource, fragmentShaderSource);
        gl.useProgram(program);

        // Get attribute and uniform locations
        const positionAttributeLocation = gl.getAttribLocation(program, 'a_position');
        const resolutionUniformLocation = gl.getUniformLocation(program, 'u_resolution');
        const colorUniformLocation = gl.getUniformLocation(program, 'u_color');

        // Create vertex buffer
        const vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);

        // Set up font
        const font = 'sans-serif';
        const fontSize = 64;

        // Set font style
        const fontString = `${fontSize}px ${font}`;
        gl.font = fontString;

        // Get text width and height
        const text = 'Hello, WebGL!';
        const textWidth = gl.measureText(text).width;
        const textHeight = fontSize * 1.2;

        // Set vertex buffer data
        const x1 = 0;
        const y1 = 0;
        const x2 = textWidth;
        const y2 = textHeight;
        const positions = [
            x1, y1,
            x2, y1,
            x1, y2,
            x1, y2,
            x2, y1,
            x2, y2,
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

        // Set canvas size
        canvas.width = textWidth;
        canvas.height = textHeight;

        // Set uniform values and render
        gl.uniform2f(resolutionUniformLocation, canvas.width, canvas.height);
        gl.uniform4f(colorUniformLocation, 0, 0, 0, 1);
        gl.drawArrays(gl.TRIANGLES, 0, 6);

        // Get text dimensions
        const textDimensions = {
            width: textWidth,
            height: textHeight,
        };



        // Utility function to create a WebGL program
        function createProgram(gl, vertexShaderSource, fragmentShaderSource) {
            const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
            const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                throw new Error('Failed to link program: ' + gl.getProgramInfoLog(program));
            }
            return program;
        }

        // Utility function to load a shader
        function loadShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                throw new Error('Failed to compile shader: ' + gl.getShaderInfoLog(shader));
            }
            return shader;
        }
    </script>
</body>

</html>